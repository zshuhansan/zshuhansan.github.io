{"pages":[],"posts":[{"title":"介绍一下自己，还有这个博客","text":"先自我介绍下我是北航的在读本科生，空间科学专业，做了个标签让介绍更直观一点 这个博客的搭建技术路线这个博客的框架是hexo,跑在我自己的树莓派上，部署方式是nginx，目前用的是sakura frp做内网穿透。唯一的缺点就是我是用内网在往树莓派上传东西，正在寻找比较好的SSH解决方案。 这个博客写点什么技术比如之前做的宝可梦大作业,包括了信息爬取，面向对象以及可视化的;以及本站的建站过程，我都会进行分享，同时可能会写一些数据结构还有计原计网的学习笔记之类(挖坑) 游戏我是个游戏食性很杂的人，什么游戏都玩一点，但是都挺菜的….本站后续可能出点游戏推荐和游戏评价啥的欢迎加我steam!好友代码：1063979847 硬件因为我是台式+笔记本+树莓派的组合,最近虚拟货币又在涨，所以本站有可能出现一些换拆机/装新机的帖,同时我可能会分享一些多端同步文件的内容。","link":"/2021/08/27/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%EF%BC%8C%E8%BF%98%E6%9C%89%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"title":"基于公众号文章的关键词词云生成","text":"项目简介假期时，作者试着用requests库爬取微信公众号文章进行词云生成，构造headers里的cookie条目时碰到了一些困难。前两天看到selenium这个库，可以通过模拟用户的点击和输入直接获取想要爬取的页面，cookie构造也比较简单，于是重启了这个项目 技术路线项目可分为三个部分，信息爬取、信息清洗和词云绘制信息爬取方面，我用了前文提到的selenium这个库，配合re库选出页面的中文内容；信息清洗用到了jieba进行分词，结合网上的stopword和自己的积累进行了无意义词的排除；词云用了cloudword结合matplotlib绘图。 项目实战爬虫部分selenium的简单介绍selenium需要使用调用其他浏览器的webdriver实现对真人用户操作的模拟，该webdriver需要与对应的本机浏览器版本号一致。其基本的使用方法如下 123456789101112131415161718192021222324252627from selenium import webdriverfrom selenium.webdriver import ChromeOptions#为了避免网站对selenium的检测,我们需要在初始化时添加一些参数，此部分放在初始化之前option=ChromeOptions()#初始化一个 初始化参数类option.add_experimental_option('excludeSwitches', ['enable-automation'])#向option这个实例添加内容target=webdriver.Chrome('对应webdriver的路径',options=option)#带参数地创建了一个webdriver实例target.set_page_load_timeout(30)#设置单页面加载的最长时间target.get('url')#打开url对应的页面target.find_element_by_xpath('元素的xpath')#通过xpath寻找目标页面元素#xpath可换为class_name/css_selector/id/link_text等，分别对应不同的寻找页面元素的方式target.find_element_by_xpath('元素的xpath').click()#单击该元素target.find_element_by_xpath('元素的xpath').send_keys('数据')#向元素中输入数据#通过 元素.函数 的方式可以实现单双击、输入输出等拟人操作target.get_cookies()#获得当前页面的cookietarget.add_cookie(i)#向当前页面装载 i 这一条cookietarget.delete_all_cookies#清空当前页面的cookietarget.close()#关闭当前标签页target.quit()#关闭所有标签页，标签页只有一个时和close相同 更多的操作可参考官方文档等 获取cookie在本项目中，用了cookie进行免人工登录，在此之前我们需要人工登录一次并将cookie（json格式）存到本地，使其能够在有效时间内一直使用。图为本地cookie文件，手动装填非常麻烦 1234567891011from selenium import webdriverfrom selenium.webdriver import ChromeOptionsfrom selenium.webdriver.common.keys import Keysfrom time import sleep#此为cookie获取部分target.get('https://weixin.sogou.com/')#点进去之后手动登录sleep(30)cookie=target.get_cookies()with open('cookies.txt','w') as f: json.dump(cookie,f)#将登陆后页面的cookie存为cookies.txt文件target.close()#将该页面关闭 信息爬取和存储获取cookie后我们就可以自动化地爬取和存储信息了，首先要通过cookie绕过登录 123456789101112131415161718from selenium import webdriverfrom selenium.webdriver import ChromeOptionsfrom selenium.webdriver.common.keys import Keysfrom time import sleepimport jsonstime=1#页面加载好后停顿的时间，按理来说我们应该使其为一个正态分布，均值较小的随机数，每次都随机target.get('https://weixin.sogou.com/')#打开页面target.delete_all_cookies()#删除当前页面的cookie，防止和之后装载的冲突with open('cookies.txt','r') as f: cookies=json.load(f)#读取cookiefor i in cookies: target.add_cookie(i)#装载cookiesleep(stime)#停一下target.get('https://weixin.sogou.com/')#带着装载好cookie后再次get页面sleep(stime)#停一下target.find_element_by_xpath('//*[@id=&quot;query&quot;]').send_keys('关键词')#在自己的浏览器中F12选取搜索框，找到后copy xpath填入代码中，使用send_keys方法填入想要搜索的关键词sleep(stime)#停一下target.find_element_by_xpath('//*[@id=&quot;searchForm&quot;]/div/input[3]').click()#点击搜索键，进入搜索结果页面 自动填写和登录如图接下来的部分就很简单了，先读取搜索结果的条数确定爬取文章的数量，在try-except框架下通过click()点开每一篇文章，并使用.page_source获取整个页面的html内容，用re匹配其中所有的中文内容并保存即可。 信息清洗没有清洗过的文本，高频词都是些 给/航小萱/点亮/1000个/在看 这样的与搜索内容无关的词，所以我们需要在结果中剔除掉这些内容我目前用的方法比较笨，先用jieba库将所有文本切成一个一个的词，将全部要清洗的词从本地读入为列表，统计词频时，若该词为要清洗的词，不统计。代码如下 1234567891011121314151617import jiebaimport jieba.analysewith open('新冠.txt','r',encoding='utf-8') as f: txt=f.read()#读入所有公众号文章文本with open('stopword.txt','r',encoding='utf-8') as f: stopword=f.read()#读入要清洗的词stopword=stopword.split('\\n')#转为列表#统计词频并按频率排序words = jieba.cut(txt, cut_all=False)#cut结果是一个可迭代的数据count={}for word in words: if word in stopword or len(word)&lt;2:#是否统计 continue else: count[word]=count.get(word,0)+1outcount=list(count.items())outcount.sort(key=lambda x: x[1], reverse=True) 简单绘图接下来的就很简单了，设置图的参数等比较麻烦，我就基本上全默认了 12345678910import matplotlib.pyplot as plt from wordcloud import WordCloudimport PIL.Image as Imagecloud=[]for i in range(50): cloud.append(outcount[i][0])wordcloud=WordCloud( background_color='white',font_path = 'msyh.ttc',margin=2).generate('/'.join(cloud))#generate的参数好像不能是列表(?)plt.imshow(wordcloud)plt.axis('off')plt.show() 效果如图 总结一下项目实现了关键词搜索-爬取公众号文章-数据清洗-词云绘制的流程，但仍然有一些遗憾，以后看着补吧，包括但不限于:出现人机验证后被卡、绘图的自定义功能、清洗和切词的更快速处理…..从昨晚吃完饭到今天的课余时间里完成了还是挺高兴的，乐 参考链接https://jimzhang.me/2020/03/Python%E4%B8%ADselenium%E5%BA%93%E6%8C%87%E5%AF%BC/https://zhuanlan.zhihu.com/p/60852696https://cloud.tencent.com/developer/article/1722974https://www.icode9.com/content-1-1105164.htmlhttps://blog.csdn.net/weixin_30256505/article/details/101171289 写聚合页抓一堆毫不相干页面来的网站是屑","link":"/2021/11/02/%E5%9F%BA%E4%BA%8E%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AF%8D%E4%BA%91%E7%94%9F%E6%88%90/"},{"title":"使用hexo创建博客并部署到GitPages&#x2F;树莓派上(未完结)","text":"前言搭建这个博客着实费了些时间和精力，踩了不少坑，这篇博文用来记录我的搭建过程，以期记录，也让读者能够少走弯路，避免网上一堆灌水垃圾的误导…项目最后的实现效果也不错，我在两台Win PC上都可以编辑我的博客并即时更新到我的仓库，且外网能正常访问我的博客 基本的技术路线网站框架: Hexo部署仓库: GitPages和我自己的树莓派服务器部署: Nginx内网穿透: 目前是花生壳 实现过程Hexo在Win PC上的安装和基础配置安装依赖项和Hexo本体 Git项目依赖于Git做部署，需要提前下载好。下载地址: https://gitforwindows.org安装就直点确定就好检查Git是否安装完成:命令行输入git --version输出和图差不多就行 Node.JsNode.Js是hexo的依赖项，也需要提前下载并安装下载地址: https://node.js.org/en/download/检查类似Git,输入node -v Hexonodejs还给了我们npm这么个包管理工具，我们可以直接用npm安装hexo，打开命令行，输入npm install -g hexo-cli即可安装，输入hexo -v检查版本确认是否安装成功 初始化和简单配置仍然是打开命令行，我们来初始化我们的本地博客。输入d:转到d盘(其他哪个盘都行)，然后输入hexo init 放博客的文件夹名字等待初始化完成即可。完成后文件夹应该长这样然后cd 文件夹名字先后输入hexo cleanhexo s你就可以在 http://localhost:4000/ 看到一个最初始的博客界面了，它长这个样子 写一篇博文还是命令行界面的博客文件夹目录下，我们可以输入hexo new 博文的名字来创建一篇博文。此时d:/博客文件夹/source/_posts/中会出现一个博文名字.md的文件，支持Markdown语法，我们用顺手的编辑器对博文进行编辑即可。!!注意:插图时应在_post文件夹里新建一个和博文同名的文件夹，将插图放入此文件夹中，博文使用该图时，引用格式应该为![](图片名字.png(也可能是jpg什么的，看你那张图片是什么格式)) 将博客部署到GitPages上Github仓库建立在Github上建立一个仓库，仓库的名字是你的github用户名.github.io 修改部署设置这时候我们需要用到刚才的git了，我们需要生成一个ssh密钥，让github仓库能认出我们这台电脑。首先我们在命令行中执行ssh-keygen -t rsa -C 然后我们打开C盘/用户/用户名/.ssh，用记事本打开id_rsa.puh这个文件，并全选复制其内容。然后我们打开github，点击自己的头像后选择setting，在ssh and gpg keys中选择new ssh key，标题随意，粘贴刚才复制的内容即可。验证:在命令行中执行ssh -T git@github.com,输出末尾句是Hi github用户名,You've successfully .....即可。然后我们来设置hexo设置，在我们之前创建的博客文件夹中，找到\\source_posts_config.yml，打开该文件，找到deploy项,改写成如下形式 1234deploy:- type: git repo: https://github.com/你的github名字/你的github名字.github.io.git branch: master 将博客部署到树莓派上仍然是命令行，我们cd到创建的博客文件夹，执行hexo d，等待完成即可，等待1min，我们就可以在”你的github名字.github.io”这个网站看到你的博客了。 树莓派上Nginx的配置用花生壳进行内网穿透花生壳是我目前用的内网穿透方案","link":"/2021/10/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0Gitpages-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A/"},{"title":"美赛准备-LINGO编程","text":"作者打算备战美赛了，”美赛准备”这个系列用于留档复习和供读者参考(或许)留档参考类的博客会很不讲究，主要是我能看懂就行…参考的MOOC是西北工业大学，名字就叫数学建模的课程 什么是LINGO数学建模中有一类优化模型，其大体框架是:在一定条件的约束下，合理分配资源，使其效率/性价比等属性最优秀。LINGO是专用于处理数学规划问题(线性/非线性规划，二次规划和整数规划等)的软件包，跑起来非常快. LINGO怎么用快速入门可直接看3.LINGO应用题实例,结合注释应该能懂个差不多。1.和2.写的太烂了。 1.LINGO的编写格式以MODEL开始，END结束(12版本后好像就不需要用这个了，我没有确定过)，中间为语句，统共分四大部分。 1.1 集合部分以SETS:开始，ENDSETS结束，这一部分用来定义必要的变量，如果要在程序中使用数组，就必须在该部分定义。LINGO中集合有两类 1.1.1 原始集合定义格式是集合名/member list 或者(1..n)/:attribute,attribute...;冒号的意思是可以有很多个以逗号分隔的attribute示例:Person/1..10/:A;Task/1..12/:B; 1.1.2 导出集合其实就是多维集合(集合的集合)，定义格式是集合名(已定义的集合1,已定义的集合2,可以再加):attribute,attribute....;示例:Link(Person,Task):X;括号中的数组必须是之前定义过的数组的名字 1.2 目标和约束部分这部分定义了目标函数和约束条件，需要用到LINGO的内置的函数(求和，比较等)，是求解优化类问题的核心，做题之前可以把条件都列出来再对应编写程序，绝对不能在这里出错。 1.3数据部分以DATA:开始,以END DATA结束，实现对集合的属性输入必要的数值格式为attribute=value_list;示例A=1.25 3 4 5 6 12 5 7 8 9; 1.4初始化部分以INIT开始，END INIT结束，给集合的属性(数组给初值)，用法和DATA部分是一样的，所有就不用了已经。 1.5 注意LINGO不区分变量中的大小写字符LINGO假设所有变量非负所有语句(包括注释)要以;结尾 2.LINGO的内部函数LINGO建立优化模型可以大量使用内部函数，这些函数大多以@打头 2.1常用数学函数@ABS(X) 返回变量X的绝对数值.@COS(X) 返回X的余弦值，X的单位为弧度@EXP(X)返回指数函数值，其中e=2.72828…@FLOOR(X)向0靠近返回X的整数部分.@LGM( X) 返回Γ函数的自然对数值.@LOG( X) 返回变量X的自然对数值@SIGN( X) 返回变量X的符号值，当X&lt;0时为-1； 当X&gt;0时为1.@SIN( X) 返回X的正弦值，X的单位为弧度@SMAX( X1, X2,…, XN) 返回一列值X1, X2,…, XN的最大值.@SMIN( X1, X2,…, XN) 返回一列值X1, X2,…, XN的最小值.@TAN( X) 返回X的正切值，X的单位为弧度 2.2集合函数这部分很重要！！集合函数的用法如下函数名(集合名|condition:expression)，|condition是条件，没有时用法省略为函数名(集合名:expression),expression是表达式。逻辑表达式中可以三种逻辑算符#AND#(与)，#OR#（或），#NOT#(非) 和六种关系算符#EQ#（等于），#NE#（不等于），#GT#(大于)，#GE# (大于等于)，#LT#(小于)，#LE#(小于等于)。常见的集合函数如下：@FOR (set_name：constraint_expressions)对集合(set_name)的每个元素 独立地生成约束，约束由约束表达式（constraint_expressions）描述.@MAX(set_name：expression)返回集合上表达式(expression)的最大值. @MIN(set_name：expression)返回集合上的表达式(expression)最小值. @SUM(set_name：expression)返回集合上的表达式(expression)的和. @SIZE(set_name)返回数据集set_name中包含元素的个数.@IN(set_name,set_element)如果数据集set_name中包含元素 set_element 则返回1，否则返回0. 2.3 变量界定函数变量函数对变量的取值范围附加限制，共有四种.@BND(L,X,U)限制L&lt;=X&lt;=U@BIN(X)限制X为0或1.@FREE(X)取消对X的符号限制(可取任意实数值).@GIN（X）限制X为整数值. 3.LINGO应用题实例题面有七种规格的包装箱要装到两辆平板车上.包装箱的宽和 高是一样的，但厚度t (厘米)和重量w (公斤)是不同的。图片给出了每种包装箱的厚度，重量以及数量。每辆平板车有10.2米的地方可用来装包装箱(像面包片那样)， 载重为40吨。由于地区货运的限制，对C5,C6,C7类包装箱的 总数有一个特别的限制：这三类包装箱所占空间(厚度)不能 超过302.7厘米。问题要求：设计一种装车方案，使剩余的空间最小。 分析我们的目标函数是两辆车的总剩余空间，要使其最小。而约束条件大体有三:对于两辆车分别有重量不超和厚度不超，对于总体来说第5、6、7种总厚度不超。还有隐藏的条件是包装箱的件数是整数。在知道了目标函数和约束条件后，就可以开始编程求解了 上代码！!后是注释，以;结尾 1234567891011121314151617181920212223242526272829303132333435363738sets:num/1..7/:w,t,n,x,y;!定义了名字分别是是w/t/n/x/y的5个长度为7的数组;!有点像是定义了一个num类，实例化了w、t、n、x、y这么5个对象!我自己是这么理解的!w,t分别是各包装箱的重量和长度;!n是各包装箱的数量;!x,y分别是第一二辆车上各包装箱的数量;endsets!set:和endsets内的部分用来定义我们需要的变量;data:t=48.7,52.0,61.3,72.0,48.7,52.0,64.0;!给t这个长度为7的数组赋初值，后面两行类似;w=2000,3000,1000,500,4000,2000,1000;n=8,7,9,6,6,4,8;enddata!data用来给变量赋值;min=(1020-@sum(num:t*x))+(1020-@sum(num:t*y));!上面这行就是我们的目标函数表示;!min在此处的意思是我们的目标函数是等号左边项取最小;!@sum(num:t*x)指t和x的每一个对应项相乘，后对其求和，其实就是求点积;!@sum(num:t*x)的结果就是第一辆车包装箱的厚度;!整个式子即两辆车剩余空间(长度)最小;@sum(num:t*x)&lt;=1020;@sum(num:t*y)&lt;=1020;!两辆车分别长度不超10.2米;@sum(num:w*x)&lt;=40000;@sum(num:w*y)&lt;=40000;!重量分别不超40吨;@for(num(i):x(i)+y(i)&lt;=n(i));!对于num这个数组类的每一项，都有x,y的第i项小于n的第i项;!代表总包装箱数量不超;@sum(num(i)|i#ge#5#and#i#le#7:(x(i)+y(i))*t(i))&lt;=302.7;!|i#ge#5#and#i#le#7给i加了限定条件;!i#ge#5 指i大于等于5;!#and#表示且;!i#le#7 i小于等于7;@for(num:@gin(x));!x的每一项都是整数;@for(num:@gin(y)); 运行结果如下最短距离是0.6 评论区装上了好耶(","link":"/2021/11/10/%E7%BE%8E%E8%B5%9B%E5%87%86%E5%A4%87-LINGO%E7%BC%96%E7%A8%8B/"},{"title":"用py做一个简易的宝可梦作战系统(未完结)","text":"项目介绍这个项目是我大一下学期《大学计算机基础》的结课大作业选题之一，要求…. 这篇博文将实现过程分为如下的几个部分 数据爬取 面向对象的对象设计 对战界面设计 对战计算设计 数据爬取 爬虫技术路线由于第一到第八世代宝可梦共800余只，爬取信息条目数量较少，所以我使用了比较基础的requests+BeautifulSoup4+re组合，进行宝可梦信息爬取和提取，配合OS和Numpy进行保存。 爬虫爬取信息确定 既然是要做战斗系统，那么就需要考虑宝可梦的属性，攻防数值，技能列表以及技能的各项属性。而经验值和进化的问题由于各世代有些微差异，该项目将不会涉及。处于以上思考，我将爬取分成了以下两个部分。1.宝可梦信息爬取:内容包括宝可梦名称、头像、攻防和血量属性(最小值和最大值)、技能列表。 2.宝可梦技能信息爬取:内容包括技能属性、PP、伤害上下限以及技能附带的特殊效果(用正则表达式进行匹配) 爬虫实现Whenever我们使用爬虫，都应该先检查网站robots协议，经检查协议为空，那么我们就可以开始我们的信息爬取了。我的两只爬虫大致思路都相同: 1.try-except模式下先链接每只宝可梦/每个技能网页并获取内容，失败时在终端打印”xx宝可梦/技能爬取失败” 1234567891011121314userkv={'user-agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', 'accept-language':'zh-CN,zh;q=0.9' }#这一部分是我们打开网页时向网页表明身份的键值对。 #一些服务器会自动拒绝掉爬虫的http请求，所以我们要对爬虫做一些伪装。 #我们可以在浏览器中打开网页，F12后在Network中找到页面条目，在其中找到requests-headers项目（如图），替换即可。def getHTMLText(url): try: r=requests.get(url,timeout=30,headers=userkv) r.raise_for_status()#链接出错时会抛出一个错误跳转到except r.encoding='utf-8'#确定编码方式为utf-8 return r.text#返回网页HTML内容 except: return '' 2.得到网页内容后按照正则表达式匹配以及网页html标签的排列规律，提取信息并存取 爬取宝可梦信息首先我们进入宝可梦图鉴，F12检查页面属性 在宝可梦名称所在标签有对应的宝可梦页面链接后缀，直接进行访问即可。而在每个宝可梦的单独页面中，可以通过正则表达式匹配标签对应的注释，判断如: if (表达式) in 标签.attrs，找到标签特点即可 爬取宝可梦技能信息宝可梦的技能列表爬取就更简单了，直接在招式图鉴里把信息录下即可。 爬取结果展示宝可梦基础信息技能基础信息 面向对象面向对象是为了对战调用信息更加完善，主要分为单个宝可梦及其技能以及整个背包的设计，主要还是通过py的列表(即哈希表)来实现。同时在初始化前需要读取之前保存的数据。 单个宝可梦的面向对象特简单，我放个代码段。 1234567891011121314151617181920212223242526272829303132pokemen_path='D:/OneDrive/python垃圾代码/基于requests获得宝可梦信息/pokemen.xlsx'all_pokemen=pd.read_excel(pokemen_path)all_pokemen.set_index('name',inplace=True)all_pokemen.to_excel(pokemen_path)def dice(ran):#在已知能力值区间内取出随机值 min=int(ran.split(' - ')[0]) max=int(ran.split(' - ')[1]) if min &lt;max:ret=np.random.randint(min,max) else:ret=min return retclass Pokemen(): def __init__(self,pokemen,skill): #pokemen是Dataframe,skill是技能名列表 self.name=pokemen.name self.attr=pokemen['attr'] self.hp=dice(pokemen['HP']) self.f_hp=self.hp self.atk=dice(pokemen['攻击']) self.defense=dice(pokemen['防御']) self.s_atk=dice(pokemen['特攻']) self.s_defense=dice(pokemen['特防']) self.speed=dice(pokemen['速度']) self.skill={} self.neg=''#宝可梦的负面状态 for i in skill: try: self.skill[i]=Skill(all_skill.loc[i]) except: print('\\n%s技能初始化失败\\n'%i) print(&quot;%s初始化成功&quot;%self.name) 宝可梦技能还有背包的初始化 类似地，唯一注意的就是要有pp(或其他战斗属性)最大值和战时状态值的区分 未完待续….. py的列表真是好py就是最好的语言！！！","link":"/2021/08/31/%E7%94%A8py%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E5%AE%9D%E5%8F%AF%E6%A2%A6%E4%BD%9C%E6%88%98%E7%B3%BB%E7%BB%9F/"},{"title":"计网学习笔记-Socket","text":"计网的学习笔记，用于留档复习和供读者参考(或许)本篇Socket主要是WinSock,也差不多少 Socket是什么socket提供了应用层和传输层间的接口。应用层借助底层向另一端的应用层传输数据或进行控制时，需要调用应用编程接口API，将应用进程控制权和操作系统控制权进行转换。Soket编程就是对这些API进行操作。 Socket怎么用Socket的基本用法像py/c等都对Socket有支持，用法有细微的不同，我在代码段里写的是c的版本，闲了再更新 头文件123#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment (lib, &quot;ws2_32.lib&quot;) //这一句用来加载 ws2_32.dll 主函数123456789101112131415161718192021int main(){ WSADATA wsaData; //初始化我们要使用的winsock库 //接下来的代码用于检查是否初始化成功 //WSAStartup()返回值为0说明成功 //第一个参数如果写MAKEWORD(2, 1)是调用2.1版本的winsock,我用的是2.2 //WSAStartup()的第二个参数就是我们之前初始化的结构变量wsaData int isright; isright=WSAStartup(MAKEWORD(2, 2), &amp;wsaData); if (isright!=0) { printf(&quot;init failed,check the code&quot;); return -1; } else printf(&quot;init successfully!\\n&quot;);/*正式建立TCP连接的部分，我在后面将分为客户端和服务器端两部分来写*/ WSACleanup();//停止对winsock库的引用 return 0;} Socket客户端程序设计客户端程序流程1.确定目标服务器ip地址和端口号2.创建本地套接字3.与服务器进行连接4.按照应用层协议通信(发送/接收信息)5.关闭/释放连接 客户端的TCP连接部分(之前代码缺失的部分)对于客户端，将(1,2,3,4,5步的代码)填入即可简单运行 创建套接字并连接服务器(1,2,3步)123456789101112//确认并装填目标服务器信息struct sockaddr_in sockAddr;memset(&amp;sockAddr, 0, sizeof(sockAddr)); //将变量sockAddr对应内存空间的每个字节都用0填充，相当于初始化sockAddr.sin_family = AF_INET;sockAddr.sin_addr.s_addr = inet_addr(&quot;服务器的ipv4地址&quot;);sockAddr.sin_port = htons(端口号(不带括号));//创建本地套接字SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);//与服务器进行连接connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); 这一部分的函数方法和数据结构详解如下 123456789101112131415161718192021SOCKET sd = socket(protofamily,type,proto)//创建一个套接字//第一个参数是协议族，对TCP/IP协议时为AF_INET/*第二个参数是套接字的类型，对于TCP/IP，可创建类型为SOCK_STREAM(流式套接字，面向TCP),SOCK_DGRAM(数据报套接字，面向UDP)或者SOCK_RAW(原始套接字，直接面向网络层IP/ICMP/IGMP，需要管理员权限)的套接字*///第三个参数是协议号，默认是0，如果有多个，需要将不同的协议声明对应的协议号struct sockaddr_in { short sin_family; //地址族，AF_INET是internet协议的ipv4 u_short sin_port; //16位的端口号 struct in_addr sin_addr; //32位的ip地址 char sin_zero[8]; //用来储存sockaddr数据};connect(SOCKET sd,struct sockaddr_in* saddr,int saddrlen)//客户端调用来使客户端套接字与saddr指向的服务器地址进行连接//第一个参数是我们之前创建的套接字//第二个参数是struct sockaddr_in的指针变量saddr，其指向的内容是服务器的ip+端口号//第三个参数是struct sockaddr_in变量的大小(占用的字节数) 接收服务器传来的数据(第4步)123char info[MAXBYTE] = { 0 };recv(sock, info, MAXBYTE, NULL);//内容会被存到info这个长255的字符串中 数据的接收函数方法详解如下 123recv(sd,*buf,len,flags)recvfrom(sd,*buf,len,flags,destaddr,addrlen)//没有to和from是TCP和用过connect的UDP的函数，有的就是UDP 向服务器发送数据(第4步)12//第二个参数是指针，第三个是字符串长度send(sd,info,len(info),NULL); 数据的发送函数方法详解如下 123send(sd,*buf,len,flags)sendto(sd,*buf,len,flags,destaddr,addrlen)//没有to和from是TCP和用过connect的UDP的函数，有的就是UDP 关闭/释放套接字(第5步)在插入部分的最后，要关闭/释放所有程序中创建的套接字本示例中为closesocket(sock);函数用法为 1234int closesocket(SOCKET sd)//套接字结构内会记录被多少个进程所引用，调用一次该函数会将此值-1，减到0才算是将该套接字关闭。//此时注意，一个进程的多个线程不重复计数//返回值为0算成功 ip处理客户端可能使用域名或者ip地址访问服务器，而ip协议使用的是32位二进制的ip地址，所以我们需要在程序调用时将ip或域名转换到32位ip 1234567891011inet_addr()//点分式十进制ip转为32位ipgethostbyname()//域名到32位ip地址//注意此处gethostbyname函数返回一个指向hostent结构的指针struct hostent{ char *h_name; //正式主机名 char **h_aliases; //主机别名 int h_addrtype; //主机IP地址类型：IPV4-AF_INET int h_length; //主机IP地址字节长度，对于IPv4是四字节，即32位 char **h_addr_list; //主机的IP地址列表 取[0]为主机ip};#define h_addr h_addr_list[0] 解析协议号客户端可能会使用协议名来指定协议，此时我们需要将协议名转换为协议号使用getprotobyname()实现 123456struct protoent { char *p_name; //正式协议名 char **p_aliases; //协议的别名列表 int p_proto; //协议号 }; Socket服务器端程序设计服务器有很多形式，一个一个处理信息的(逐个响应请求)，并发处理信息的(每收到一个请求就新建一个套接字和进程的)等等等等，本文只展示最简单的一个只响应一次请求就关闭的服务。 服务器端流程还是一样，将下述各步骤的代码嵌入之前代码缺失的地方即可构成完整程序 1.创建本地套接字，并绑定自己的ip地址和端口号作为服务器，可能有多个网络连接，以至于有多个ip地址，我们使用通配符来match我们所有的地址 1234567SOCKET servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);struct sockaddr_in sockAddr;memset(&amp;sockAddr, 0, sizeof(sockAddr)); sockAddr.sin_family = AF_INET; //截止这里还和客户端一样sockAddr.sin_addr.s_addr = htonl(INADDR_ANY); //htonl是将本地ip转为32位的ipsockAddr.sin_port = htons(1234); //和客户端一样的端口bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); 2.监听端口并与发送请求的客户连接作为服务器，要时刻监听向这个端口发送的请求 123456listen(servSock, 20);//第二个参数是客户请求队列的最长长度SOCKADDR clntAddr;int nSize = sizeof(SOCKADDR);SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);//创建新套接字用于连接客户端//接下来的通信就使用这个clntSock 3.按照应用层协议通信(发送/接收信息)和客户端是一样的 4.关闭/释放连接123closesocket(clntSock);//关闭通信套接字closesocket(servSock);//关闭监听用套接字，因为我们这个程序只通信一次//想要多次或并发地操作，那就需要用循环来不断处理请求队列中的请求，本文不详述 如果你有两台win电脑，可以尝试一下在内网里建立这么一个tcp连接玩一玩，方法就是都连接校园网或自己的家庭网络之类的，将客户端程序里的ip改为服务器的ip(服务器电脑打开命令行输入ipconfig可查询)，然后先开服务器程序，再打开客户端程序。如果只有一台，可以将客户端程序里服务器的ip改为127.0.0.1,然后服务器程序、客户端程序跑着试试。","link":"/2021/11/05/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Socket/"}],"tags":[{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"词云","slug":"词云","link":"/tags/%E8%AF%8D%E4%BA%91/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"美赛","slug":"美赛","link":"/tags/%E7%BE%8E%E8%B5%9B/"},{"name":"LINGO","slug":"LINGO","link":"/tags/LINGO/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"}],"categories":[]}